<script>
function generate() {
  if (points.length < 3) return;

  const workW = Number(document.getElementById("width").value);
  const poly = turf.polygon([[...points, points[0]]]);
  const bbox = turf.bbox(poly);

  let y = bbox[1];
  let lines = [];

  // --- collect each working line ---
  while (y <= bbox[3]) {
    const scan = turf.lineString([[bbox[0] - 10, y], [bbox[2] + 10, y]]);
    const hits = turf.lineIntersect(scan, poly);

    if (hits.features.length >= 2) {
      // sort intersections by X (left -> right)
      const pts = hits.features
        .map(f => f.geometry.coordinates)
        .sort((a, b) => a[0] - b[0]);

      lines.push({
        left: pts[0],
        right: pts[pts.length - 1]
      });
    }
    y += workW * 20;
  }

  // --- build single continuous path (zig-zag) ---
  let path = [];
  lines.forEach((ln, i) => {
    if (i % 2 === 0) {
      path.push(ln.left, ln.right);
    } else {
      path.push(ln.right, ln.left);
    }
  });

  // --- redraw ---
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (img.complete) {
    const scale = Math.min(
      canvas.width / img.width,
      canvas.height / img.height
    );
    const w = img.width * scale;
    const h = img.height * scale;
    const x = (canvas.width - w) / 2;
    const y0 = (canvas.height - h) / 2;
    ctx.drawImage(img, x, y0, w, h);
  }

  // draw polygon
  ctx.strokeStyle = "white";
  ctx.beginPath();
  points.forEach((p, i) => i ? ctx.lineTo(p[0], p[1]) : ctx.moveTo(p[0], p[1]));
  ctx.closePath();
  ctx.stroke();

  // draw single path
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 2;
  ctx.beginPath();
  path.forEach((p, i) => {
    if (i === 0) ctx.moveTo(p[0], p[1]);
    else ctx.lineTo(p[0], p[1]);
  });
  ctx.stroke();
}
</script>
